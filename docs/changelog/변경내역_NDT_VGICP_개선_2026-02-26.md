# NDT/VGICP Factor 코드 변경내역 (2026-02-26)

이 문서는 NDT 및 VGICP Factor의 수렴 성능과 정확도 개선을 위해 수행한 주요 코드 변경 사항을 정리합니다. Magnusson의 2009년 박사 학위 논문과 Koide의 VGICP(ICRA 2021) 논문을 바탕으로 수식과 구현을 정렬했습니다.

## 1. 대상 파일 및 참조
- **대상 파일**:
  1. `thirdparty/gtsam_points/include/gtsam_points/factors/impl/integrated_ndt_factor_impl.hpp`
  2. `thirdparty/gtsam_points/src/gtsam_points/factors/integrated_matching_cost_factor.cpp`
  3. `thirdparty/gtsam_points/include/gtsam_points/factors/integrated_vgicp_factor.hpp`
  4. `thirdparty/gtsam_points/include/gtsam_points/factors/impl/integrated_vgicp_factor_impl.hpp`
  5. `src/main.cpp`
- **참조 문헌**:
  - Magnusson, M. (2009). The Three-Dimensional Normal-Distributions Transform.
  - Koide, K., et al. (2021). Voxelized GICP for Fast and Accurate 3D Point Cloud Registration.

## 2. 변경 요약 테이블

| 번호 | 변경 항목 | 대상 파일 | 결과 |
| :--- | :--- | :--- | :--- |
| Fix 1 | NDT Factor 수식 리팩토링 | `integrated_ndt_factor_impl.hpp` | Magnusson 표준 수식과 일치, 안정성 향상 |
| Fix 2 | error() 내 Correspondence 업데이트 | `integrated_matching_cost_factor.cpp` | LM tryLambda 과정의 NDT 발산 문제 해결 |
| Fix 3 | VGICP Update Tolerance 추가 (실패) | `integrated_vgicp_factor.hpp/impl` | 효과 없음 확인 (실패 원인 분석 완료) |
| Fix 4 | VGICP error() 메서드 오버라이드 | `integrated_vgicp_factor.hpp/impl` | Voxel 유지 및 Mahalanobis 재계산 분리로 수렴 성공 |
| Fix 5 | Voxel Resolution 조정 (0.5m → 1.0m) | `src/main.cpp` | 실외 환경 최적화로 NDT/VGICP 정확도 급증 |
| Fix 6 | NDT 수렴 속도 개선 (weight^0.25 + outlier_ratio=0.01) | `integrated_ndt_factor_impl.hpp`, `src/main.cpp` | 92→34 iterations (63% 감소), 시간 59% 감소 |

---

## 3. Fix 1: NDT Factor 리팩토링

`integrated_ndt_factor_impl.hpp`의 `evaluate()` 메서드에서 NDT 코스트 함수와 가중치 계산 로직을 Magnusson 논문에 맞춰 수정했습니다.

### 3.1 e_scaled 가드 제거 (버그 수정)

기존 코드는 `gauss_d2 * e_term > 1.0`일 때 해당 포인트의 기여를 0으로 만들었습니다. `gauss_d2 ≈ 5~8`이므로 `e_term > 0.13~0.2`인 경우, 즉 **Mahalanobis 거리가 작은(= 잘 정렬된) 포인트들이 오히려 필터링**되는 심각한 버그였습니다.

```cpp
// ❌ 변경 전: well-aligned 포인트가 제거됨
double e_scaled = gauss_d2 * e_term;
if (e_scaled > 1.0 || std::isnan(e_scaled)) {
  return 0.0;
}

// ✅ 변경 후: underflow 방지 + NaN만 체크
if (exponent < -700.0) {
  return 0.0;  // underflow 방지
}
double e_term = std::exp(exponent);
if (std::isnan(e_term)) {
  return 0.0;
}
```

### 3.2 score_function과 cost 분리

기존 `error = -d1 * (1 - e_term)` 변수를 Magnusson Eq. 6.9에 맞춰 분리했습니다.

```cpp
// ❌ 변경 전
const double error = -gauss_d1 * (1.0 - e_term);

// ✅ 변경 후
const double score_function = -gauss_d1 * e_term;      // Magnusson Eq. 6.9
const double cost = -gauss_d1 - score_function;         // = -d1*(1-e_term), GTSAM 호환
```

- `score_function`: 정렬이 좋을수록 **증가** (최대화 문제)
- `cost`: GTSAM LM은 cost가 **감소**해야 step을 accept하므로, 상수 `-d1`에서 score를 빼서 부호 반전
- 상수 차이이므로 gradient와 Hessian은 동일 → 최적화 동작에 영향 없음

### 3.3 derivative_scale → weight 리네이밍

Magnusson Eq. 6.12의 gradient 유도에서 자연스럽게 나오는 weight라는 의미를 명확히 했습니다.

```cpp
// ❌ 변경 전
const double derivative_scale = -gauss_d1 * gauss_d2 * e_term;

// ✅ 변경 후
const double weight = -gauss_d1 * gauss_d2 * e_term;  // 양수: d1<0, d2>0, e_term>0
```

Eq. 6.12 유도: `∂s/∂p = (-d1 * d2 * e_term) * q^T * Σ^{-1} * J` → weight = `-d1 * d2 * e_term`
---

## 4. Fix 2: error()에서 Correspondence 업데이트
GTSAM의 Levenberg-Marquardt(LM) 최적화 과정에서 발생하는 발산 문제를 해결했습니다.

- **문제점**: LM의 `tryLambda()`가 새로운 상태값으로 `error()`를 호출할 때, `linearize()` 시점에 계산된 오래된 correspondence를 사용하고 있었습니다.
- **해결책**: `integrated_matching_cost_factor.cpp`의 `error()` 메서드에 `update_correspondences(delta)`를 추가했습니다.
- **LM 흐름 분석**:
  - `linearize()` → `error(currentValues)` → `tryLambda()` → `error(newValues)` 순서로 진행되는데, `tryLambda` 단계에서도 최신 대응점을 찾아야 정확한 에러 계산이 가능합니다.
- **영향**: NDT의 진동(oscillation) 문제가 해결되었으나, 초기 상태의 VGICP가 0회 반복으로 종료되는 부작용이 발견되어 Fix 4로 이어졌습니다.

---

## 5. Fix 3: VGICP correspondence_update_tolerance 추가 (실패)
VGICP의 빈번한 업데이트를 막기 위해 임계값(tolerance)을 도입했으나 실질적인 효과를 거두지 못했습니다.

- **내용**: `correspondence_update_tolerance` 멤버와 설정 메서드를 추가하고, 변화량이 적을 때 업데이트를 건너뛰는 로직을 구현했습니다.
- **실패 원인**: Headless 모드에서 기본값이 0.0이었으며, GICP 기반 방식은 tolerance가 0이어도 정상 작동해야 하므로 근본적인 해결책이 아니었습니다.

---

## 6. Fix 4: VGICP error() 오버라이드

VGICP의 고유한 특성을 반영하여 `error()` 메서드를 재구현했습니다.

### 6.1 문제점

VGICP의 `update_correspondences()`는 ① Voxel 재검색 + ② Mahalanobis 행렬 계산을 동시에 수행합니다. Fix 2 적용 후 `error()`에서 매번 이를 호출하면 Voxel 대응이 바뀌어 cost가 오히려 증가하는 현상이 발생했습니다 (284K → 372K → 306K → 408K 진동 패턴).

### 6.2 해결책

```cpp
// error() 오버라이드 — Voxel 대응 유지, Mahalanobis만 재계산
template <typename SourceFrame>
double IntegratedVGICPFactor_<SourceFrame>::error(const gtsam::Values& values) const {
  Eigen::Isometry3d delta = calc_delta(values);
  if (correspondences.size() == frame::size(*source)) {
    update_mahalanobis(delta);  // Voxel 대응 유지, Mahalanobis만 재계산
  } else {
    update_correspondences(delta);  // 최초 호출 시 전체 업데이트
  }
  return evaluate(delta);
}
```

- `linearize()`: 기존대로 full `update_correspondences()` (Voxel 검색 + Mahalanobis)
- `error()`: `update_mahalanobis()`만 호출 (frozen Voxel 대응으로 Mahalanobis만 재계산)

### 6.3 결과

VGICP가 37회 반복 후 안정적으로 수렴. 단, 정확도는 0.211m로 GICP(0.084m) 대비 부족하여 Fix 5로 이어졌습니다.
---

## 7. Fix 5: Voxel Resolution 변경
실외 LiDAR 데이터 환경에 적합하도록 Voxel 크기를 조정했습니다.

- **문제점**: 기존 `GaussianVoxelMapCPU`의 해상도가 0.5m로 설정되어 있었습니다. 이는 실외 광역 환경에서 노이즈에 너무 민감하게 반응하는 수치입니다.
- **근거**: Koide의 `fast_gicp` 기본값은 1.0m이며, `small_gicp` 벤치마크에서는 2.0m를 사용합니다.
- **변경 사항**: `src/main.cpp`에서 CPU 및 GPU VoxelMap 해상도를 0.5m에서 1.0m로 변경했습니다.
- **결과**: VGICP 정확도가 0.211m에서 0.113m로 47% 개선되었으며, NDT 또한 0.170m에서 0.095m로 44% 개선되는 부수 효과를 확인했습니다.

---

## 8. Fix 6: NDT 수렴 속도 개선

NDT가 92회 반복하는 문제를 34회로 대폭 감소시켰습니다.

### 8.1 문제 분석

NDT의 weight(`-d1 * d2 * e_term`)는 지수 함수로 감쇠하여, 초기 상태에서 Mahalanobis 거리가 클 때 gradient가 거의 0에 가까워집니다.

- 초기 Mahalanobis 거리 ≈ 19 → `e_term = exp(-d2/2 * 19)` ≈ 매우 작음
- weight = max의 11.1% → gradient가 작아 1회당 cost 감소율 ~1.4%
- 결과: 92회 반복해야 수렴
- GICP는 순수 2차 비용(weight 없음)이므로 12회에 수렴

### 8.2 해결책: 2단계 접근

#### (1) weight^0.25 변환 (지수 감쇠 완화)

```cpp
// ❌ 변경 전: 지수 감쇠가 너무 급격
const double weight = -gauss_d1 * gauss_d2 * e_term;

// ✅ 변경 후: 4제곱근으로 감쇠율 1/4로 완화
const double raw_weight = -gauss_d1 * gauss_d2 * e_term;
const double weight = std::sqrt(std::sqrt(raw_weight));  // weight^0.25
```

- 초기 m=19에서: weight 0.116 → `0.116^0.25` = 0.583 (5배 증가)
- 수렴 근처 m≈0에서: weight ≈ 1.044 → `1.044^0.25` ≈ 1.011 (거의 동일)
- **효과**: 먼 점의 gradient 기여가 크게 증가하면서도, 가까운 점의 기여는 유지

#### (2) outlier_ratio 0.1 → 0.01 (gradient 감쇠 추가 완화)

```cpp
// src/main.cpp
factor->set_outlier_ratio(0.01);  // 0.1 → 0.01: d2 감소로 감쇠 완화
```

- `outlier_ratio`가 작을수록 `gauss_d2` 값이 감소 → 지수 감쇠가 더 완만해짐
- `compute_ndt_params()`에서 `d2 = -2*log((1-d1)/(-d1*sqrt(8π³)/res³))` / `d1`의 관계

### 8.3 실험 과정 (단계별 결과)

| 설정 | Iterations | Time (ms) | Mean T (m) | Mean R (°) |
| :--- | :--- | :--- | :--- | :--- |
| 원래 (weight, OR=0.1) | 92 | 50,379 | 0.095 | 0.725 |
| sqrt(weight), OR=0.1 | 58 | 33,496 | 0.097 | 0.726 |
| sqrt(weight), OR=0.01 | 50 | 29,331 | 0.098 | 0.724 |
| **weight^0.25, OR=0.01** | **34** | **20,687** | **0.098** | **0.689** |

### 8.4 결과

- **Iteration 수**: 92 → **34** (63% 감소)
- **최적화 시간**: 50,379ms → **20,687ms** (59% 감소)
- **Translation 정확도**: 0.095m → 0.098m (미미한 증가, 허용 범위)
- **Rotation 정확도**: 0.725° → **0.689°** (5% 개선!)
- Rotation이 오히려 개선된 것은 weight 감쇠가 완화되면서 먼 점들의 회전 정보가 더 잘 반영된 결과로 해석됨


## 9. 벤치마크 결과 비교

각 Fix 단계별 성능 지표 변화입니다.

### Fix 1~4 적용 후 (Voxel 0.5m)
| Factor | 반복 횟수 | Mean T (m) | Mean R (deg) | 상태 |
| :--- | :--- | :--- | :--- | :--- |
| P2P | 30 | 0.096 | 0.486 | 정상 |
| P2Plane | 12 | 0.062 | 0.443 | 최상 |
| GICP | 12 | 0.084 | 0.539 | 정상 |
| VGICP | 37 | 0.211 | 1.031 | 저조 |
| NDT | 50 | 0.170 | 1.301 | 저조 |
| LOAM | 8 | 0.225 | 0.773 | 정상 |

### Fix 5 적용 후 (Voxel 1.0m)
| Factor | 반복 횟수 | Mean T (m) | Mean R (deg) | 상태 |
| :--- | :--- | :--- | :--- | :--- |
| P2P | 30 | 0.096 | 0.486 | 유지 |
| P2Plane | 12 | 0.062 | 0.443 | 최상 유지 |
| GICP | 12 | 0.084 | 0.539 | 유지 |
| **VGICP** | **21** | **0.113** | **0.623** | **크게 개선** |
| **NDT** | **92** | **0.095** | **0.725** | **정확도 대폭 향상 (속도 미흡)** |
| LOAM | 8 | 0.225 | 0.775 | 유지 |

### Fix 6 적용 후 (weight^0.25 + OR=0.01) — 최종 결과
| Factor | 반복 횟수 | Mean T (m) | Mean R (deg) | 시간 (ms) | 상태 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| P2P | 30 | 0.096 | 0.486 | 19,233 | 유지 |
| P2Plane | 12 | 0.062 | 0.443 | 9,406 | 최상 유지 |
| GICP | 12 | 0.084 | 0.539 | 11,981 | 유지 |
| VGICP | 21 | 0.113 | 0.623 | 9,037 | 유지 |
| **NDT** | **34** | **0.098** | **0.689** | **20,687** | **수렴 속도 대폭 개선** |
| LOAM | 8 | 0.225 | 0.775 | 131 | 유지 |
---

## 10. 변경 파일 세부 내용
1. `integrated_ndt_factor_impl.hpp`: NDT 수식 리팩토링, Magnusson 표준 모델 적용, weight^0.25 변환.
2. `integrated_matching_cost_factor.cpp`: 에러 계산 시 correspondence 업데이트 로직 추가.
3. `integrated_vgicp_factor.hpp`: VGICP 전용 `error()` 오버라이드 및 `update_mahalanobis()` 선언.
4. `integrated_vgicp_factor_impl.hpp`: `update_mahalanobis()` 구현 및 Voxel 고정 로직 적용.
5. `src/main.cpp`: Voxel 해상도 조정(1.0m), outlier_ratio=0.01, 시각화 개선.
---

## 11. 향후 개선 가능 사항
- **NDT**: weight 변환을 parametric하게 만들어 `set_weight_power(0.25)` 등으로 조절 가능하게 할 수 있음. H2 항(Hessian 보완) 추가, More-Thuente line search 도입 검토.
- **VGICP**: 입력 포인트 클라우드의 다운샘플링(0.25m 수준)을 적용하여 연산 속도를 높이고, `max_correspondence_distance` 제약을 추가할 예정.

## 11. 관련 문서
| 문서 | 위치 | 내용 |
|------|------|------|
| NDT 구현 비교 분석 | `docs/ndt/magnusson_implementation_comparison_ko.md` | gtsam_points NDT vs Magnusson 논문 상세 비교 |
| Weighted GN 적용 가능성 | `docs/ndt/weighted_gauss_newton_feasibility_ko.md` | Eq. 6.12/6.13 기반 weighted GN의 GTSAM 적용 분석 |
| NDT 리팩토링 상세 내역 | `docs/ndt/변경내역_ndt_magnusson_refactoring.md` | Fix 1 상세 변경 내역 (코드-수식 매핑) |
